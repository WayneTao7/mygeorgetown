function M(t,e){return t==null||e==null?NaN:e<t?-1:e>t?1:e>=t?0:NaN}class d extends Map{constructor(e,n=x){if(super(),Object.defineProperties(this,{_intern:{value:new Map},_key:{value:n}}),e!=null)for(const[r,f]of e)this.set(r,f)}get(e){return super.get(g(this,e))}has(e){return super.has(g(this,e))}set(e,n){return super.set(k(this,e),n)}delete(e){return super.delete(N(this,e))}}function g({_intern:t,_key:e},n){const r=e(n);return t.has(r)?t.get(r):n}function k({_intern:t,_key:e},n){const r=e(n);return t.has(r)?t.get(r):(t.set(r,n),n)}function N({_intern:t,_key:e},n){const r=e(n);return t.has(r)&&(n=t.get(r),t.delete(r)),n}function x(t){return t!==null&&typeof t=="object"?t.valueOf():t}function h(t){return t}function j(t,...e){return p(t,Array.from,h,e)}function m(t,e,...n){return p(t,h,e,n)}function w(t,e,...n){return p(t,Array.from,e,n)}function p(t,e,n,r){return function f(c,i){if(i>=r.length)return n(c);const s=new d,a=r[i++];let y=-1;for(const o of c){const u=a(o,++y,c),l=s.get(u);l?l.push(o):s.set(u,[o])}for(const[o,u]of s)s.set(o,f(u,i));return e(s)}(t,0)}export{d as I,w as a,M as d,j as g,m as r};
